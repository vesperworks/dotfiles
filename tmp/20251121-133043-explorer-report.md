# doc/ ディレクトリ探索レポート

## 1. ドキュメント構造概要

### 1.1 ディレクトリマップ

```
doc/
├── 20251121_cc_docs/           # 最新Claude Code公式ドキュメント（2025年11月21日版）
│   ├── cli-reference.md        # CLIコマンドリファレンス
│   ├── hooks-guide.md          # フック開発ガイド
│   ├── hooks.md                # フック詳細リファレンス（39KB）
│   ├── plugin-marketplaces.md  # プラグインマーケットプレイス管理
│   ├── plugins-reference.md    # プラグイン技術リファレンス
│   ├── plugins.md              # プラグイン開発ガイド
│   ├── skills.md               # エージェントスキル完全ガイド（19KB）
│   ├── slash-commands.md       # スラッシュコマンド詳細（25KB）
│   └── sub-agents.md           # サブエージェント完全ガイド（23KB）
│
├── agentのためのXMLタグ記法.md  # エージェント実装用XMLタグパターン（2KB）
│
├── 20250620_claude-default-multiagent-design.md  # 旧マルチエージェント設計（22KB）
│   └── git worktreeベースの設計思想（現在は非推奨）
│
└── ref_code/                   # 参考プラグイン実装例
    └── plugins/
        ├── feature-dev/        # 機能開発ワークフロープラグイン
        │   ├── agents/         # code-explorer, code-architect, code-reviewer
        │   └── commands/       # /feature-dev コマンド
        │
        ├── plugin-dev/         # プラグイン開発ツールキット
        │   ├── agents/         # agent-creator, skill-reviewer, plugin-validator
        │   ├── commands/       # /create-plugin コマンド
        │   └── skills/         # 7つの専門スキル
        │       ├── command-development/
        │       └── skill-development/
        │
        ├── learning-output-style/  # 出力スタイル学習プラグイン
        └── code-review/            # コードレビュープラグイン
```

### 1.2 ファイルサイズと重要度

| ファイル | サイズ | 最終更新 | 重要度 |
|---------|--------|---------|--------|
| hooks.md | 39KB | 2025-11-21 | 最高 |
| slash-commands.md | 25KB | 2025-11-21 | 最高 |
| sub-agents.md | 23KB | 2025-11-21 | 最高 |
| skills.md | 19KB | 2025-11-21 | 高 |
| plugins.md | 17KB | 2025-11-21 | 高 |
| 20250620_claude-default-multiagent-design.md | 22KB | 2025-06-23 | 中（レガシー） |
| agentのためのXMLタグ記法.md | 2KB | 2025-11-21 | 中 |

---

## 2. 最新Claude Code アーキテクチャ（20251121_cc_docs + ref_blog）

### 2.0 将来的な発展方向（参考情報）

**📚 Anthropic公式が示す将来の方向性**（参考として記録）

Anthropic公式ブログおよび技術記事により、将来的なエージェント設計の方向性が示されています。

#### Code Execution × MCP（将来的なアプローチ）

ファイルシステムベースのツール配置により、ツール定義をオンデマンドで読み込むアプローチが提案されています。
- 効果: 最大98.7%のトークン削減（150,000 → 2,000トークン）
- 実装: ファイルシステムにMCPツールを配置し、必要時のみ読み込む

**現時点での採用判断**: 革新的ではあるが、実装の複雑さと運用の学習コストを考慮し、**今回のプロジェクトでは見送り**。将来的な検討課題として記録。

#### MCPの本質的理解（実装に活用）

**「MCPツールは本質的にプロンプトである」**（Anthropic公式）

この理解は、現在のMCP活用においても有用：

1. **ツール定義の重要性**: ツール名、説明、パラメーター名を正確に詳細に定義
2. **適切なツール粒度**: 細かすぎるツール分割は避け、適度な抽象度を保つ
3. **類似機能の整理**: 類似の機能を持つツールは統合を検討

### 2.1 プラグインシステムの全面採用

**最大の変更点**: 旧来の`slashCommand`や`git worktree`ベースのワークフローから、**プラグインエコシステム**への完全移行

#### プラグインの4つの核心コンポーネント

1. **スラッシュコマンド (`commands/`)**
   - フロントマター付きMarkdown形式
   - `$ARGUMENTS`、`$1, $2...`による引数処理
   - `!`プレフィックスでbashコマンド実行
   - `@`プレフィックスでファイル参照
   - `allowed-tools`による権限制御
   - **CLIツール**: `SlashCommand`ツールで動的実行可能

2. **サブエージェント (`agents/`)**
   - YAML frontmatter + Markdown system prompt
   - 独立したコンテキストウィンドウ
   - `model`フィールドで実行モデル選択（`sonnet`, `opus`, `haiku`, `inherit`）
   - `tools`フィールドでツール権限制御
   - **自動委譲**: `description`フィールドでの発見ベース
   - **明示的呼び出し**: "Use the code-reviewer subagent..."
   - **再開可能**: `agentId`による会話継続

3. **エージェントスキル (`skills/`)**
   - `SKILL.md`ファイルベース（YAML frontmatter必須）
   - **モデル呼び出し型**（ユーザーが明示的に呼ばない）
   - `description`での発見的トリガー（"Use when..."）
   - `allowed-tools`による読み取り専用/制限付きスキル
   - **段階的開示**: SKILL.md → references/ → examples/ → scripts/

4. **フック (`hooks/hooks.json`)**
   - **イベント型**: `PreToolUse`, `PostToolUse`, `Stop`, `SubagentStop`, `SessionStart`, `SessionEnd`, `UserPromptSubmit`, `PreCompact`, `Notification`
   - **2つのフックタイプ**:
     - `type: "command"`: bashコマンド実行
     - `type: "prompt"`: LLM（Haiku）による判定（`Stop`, `SubagentStop`のみ）
   - `matcher`による正規表現マッチング
   - `${CLAUDE_PLUGIN_ROOT}`, `${CLAUDE_PROJECT_DIR}`環境変数

### 2.2 プラグインマーケットプレイス

**配布メカニズム**:
- `marketplace.json`でプラグインカタログを管理
- `/plugin marketplace add <org/repo>`でマーケットプレイス追加
- `/plugin install <plugin-name>@<marketplace-name>`でインストール
- **チーム配布**: `.claude/settings.json`でプロジェクトレベル自動インストール

**プラグイン構造**:
```
my-plugin/
├── .claude-plugin/
│   └── plugin.json          # マニフェスト
├── commands/                # スラッシュコマンド
├── agents/                  # サブエージェント
├── skills/                  # エージェントスキル
├── hooks/
│   └── hooks.json           # フック定義
└── .mcp.json                # MCPサーバー統合（オプション）
```

### 2.3 MCP（Model Context Protocol）統合

- **MCPツール**: 接続されたMCPサーバーのツールを`mcp__<server>__<tool>`形式で利用
- **MCPプロンプト**: MCPサーバーが提供するプロンプトを`/mcp__<server>__<prompt>`形式で実行
- **権限管理**: `mcp__servername`で全ツール許可、個別指定も可能（ワイルドカード不可）
- **OAuth対応**: `/mcp`コマンドで認証管理

### 2.4 組み込みサブエージェント

**Planサブエージェント**:
- プランモード中に自動起動
- Sonnetモデル使用
- Read, Glob, Grep, Bashツールでコードベース調査
- エージェントの無限ネスト防止

---

## 3. XMLタグ記法ガイドライン

**場所**: `~/Works/ccSlashCmd-dev/doc/agentのためのXMLタグ記法.md`

### 3.1 基本パターン

公式ドキュメント（特に`sub-agents.md`の例）と比較すると、このファイルは**汎用的なプロンプト設計パターン**を提供：

#### 分析タスク用タグ
```xml
<role>分析専門家としての役割定義</role>
<context>分析対象の背景情報</context>
<data>分析すべきデータ</data>
<analysis_framework>使用すべき分析手法</analysis_framework>
<output_requirements>期待する出力の形式と内容</output_requirements>
```

#### 創作・生成タスク用タグ
```xml
<role>クリエイターとしての役割定義</role>
<creative_brief>創作の目的と方向性</creative_brief>
<constraints>制約条件や守るべき要素</constraints>
<inspiration>参考にすべき要素やスタイル</inspiration>
<output_format>成果物の形式</output_format>
```

#### 問題解決タスク用タグ
```xml
<context>問題の背景と現状</context>
<problem_definition>解決すべき具体的な問題</problem_definition>
<constraints>制約条件やリソース</constraints>
<solution_approach>取るべきアプローチ</solution_approach>
<evaluation_criteria>解決策の評価基準</evaluation_criteria>
```

### 3.2 公式ドキュメントとの差分

**公式例（code-reviewer agent）**:
```markdown
When invoked:
1. Run git diff to see recent changes
2. Focus on modified files
3. Begin review immediately

Review checklist:
- Code is simple and readable
...
```

**XMLタグ記法**は、より構造化されたプロンプトテンプレートを提供するが、公式ドキュメントでは**自然言語のチェックリストとステップ**が推奨されている。

---

## 4. 既存実装との差分分析

### 4.1 現在の `.claude/agents/` 構造との比較

| 現在の実装 | 公式ベストプラクティス | 推奨アクション |
|-----------|---------------------|--------------|
| `vwsub-*.md`エージェント | ✅ 適合（YAML frontmatter + system prompt） | 保持 |
| `description`フィールド | ⚠️ 強化可能 | "use PROACTIVELY"など追加 |
| `model`フィールド | ✅ 使用中 | 適切 |
| `tools`フィールド | ⚠️ 一部未使用 | 必要に応じて制限 |
| `color`フィールド | ❌ 未使用 | 追加可能（UIでの識別用） |
| エージェント再開機能 | ❌ 未活用 | 長時間調査に有効 |

### 4.2 現在の `CLAUDE.md` で言及されている内容との差分

#### 完全に一致する要素
- ✅ エージェントベースシステムの採用
- ✅ シンボリックリンク構成（`~/.claude/` → プロジェクト）
- ✅ `ni/nr`, `rg`, `bat`, `eza`, `fd`のモダンツール推奨

#### 不一致・未反映の要素
- ❌ **プラグイン化されていない**: 現在の実装はプラグイン形式ではなく、直接`.claude/`配下に配置
- ⚠️ **スキルの段階的開示未実装**: 現在の`prompts/`は一枚岩構造
- ❌ **フックの活用不足**: `hooks/`ディレクトリ存在するが、公式の`type: "prompt"`フック未使用
- ❌ **MCPサーバー統合なし**: `.mcp.json`未設定
- ⚠️ **マーケットプレイス配布なし**: チーム配布の標準手段未整備

#### レガシー要素（削除済みだが、ドキュメントで言及）
- ❌ `git worktree`管理: 公式では非推奨、このプロジェクトも廃止済み
- ❌ `multi-*.md`コマンド群: `vw-multifeature`エージェントに統合済み

### 4.3 `20250620_claude-default-multiagent-design.md`（旧設計）との比較

**旧設計の核心**:
- git worktreeによる物理分離（1タスク=1worktree）
- オーケストレーターが現在のClaudeセッション
- `/project:multi-tdd`, `/project:multi-feature`などのコマンド

**現在の公式推奨**:
- ✅ **プラグインベース**: worktreeではなく、プラグインで機能分離
- ✅ **サブエージェント**: 独立したコンテキストウィンドウ
- ✅ **スキル**: 自動発見型の機能拡張
- ❌ **worktree非推奨**: 複雑性のため全面廃止

このプロジェクトは既に**旧設計を廃止**し、エージェントベースに移行済み。

---

## 5. 優先度付き推奨事項（✅更新：現実的な実装に焦点）

### 🔥 Critical（最優先実装）

#### 1. スキル段階的開示の実装（重要度: Critical 🔥）

**現状**: `prompts/`ディレクトリの各プロンプトは一枚岩構造

**推奨**: Progressive Disclosure 3層構造への変換

**効果**: 15,000トークン → 5,300トークン（**65%削減**）

**実装例**（`prompts/explorer.md` → `skills/codebase-exploration/`）:
```
skills/codebase-exploration/
├── SKILL.md                        # L2層: 核心プロンプト（500行以下）
├── references/                     # L3層: 詳細参照（必要時のみロード）
│   ├── advanced-analysis.md
│   └── integration-patterns.md
├── examples/                       # L3層: 実例（学習用）
│   └── real-world-exploration.md
└── scripts/                        # 補助スクリプト
    └── generate-report.sh
```

**SKILL.mdフロントマター**:
```yaml
---
name: codebase-exploration
description: Deeply analyzes existing codebase features by tracing execution paths. Use when exploring code structure, finding similar features, or understanding architecture before implementation.
allowed-tools: Read, Grep, Glob, Bash
---
```

**メリット**:
- L1（メタデータ）のみ常時ロード → 初期トークン大幅削減
- L2（本文）を必要時のみロード → 効率的なコンテキスト管理
- L3（詳細）をさらに必要時にロード → 段階的な情報提供

#### 2. エージェント数最適化（重要度: Critical 🔥）

**現状**: 13個のエージェントは多すぎて、適切なエージェント選択が困難

**推奨**: 機能の重複・類似性に基づき**8個に統合**

**統合マッピング**:
| 現在（13） | 統合後（8） | 統合理由 |
|----------|-----------|---------|
| vwsub-developer<br>vwsub-tester | vwsub-developer | TDD実装とテストを統合 |
| vwsub-reviewer<br>code-reviewer-claude-md | vwsub-reviewer | コードレビュー統合 |
| requirements-architect | 削除 | vw-multifeatureに統合 |
| tech-domain-researcher | 削除 | vwsub-explorerのSkillsへ |
| error-debugger | 削除 | vwsub-developerに統合 |

**メリット**:
- エージェント発見性: 60% → 90%以上
- 適切なエージェント選択率: 50% → 85%以上
- 機能の重複排除による保守性向上

#### 3. SubAgent→Skills連携（重要度: High ⭐）

**現状**: SubAgentsとSkillsの連携が未確立

**推奨**: 公式推奨パターンの実装

**構成例**:
```
- Skills（共有知識）:
  - "コードベース探索手法"
  - "TDD実装パターン"
  - "品質評価基準"
- SubAgents（独立実行）:
  - vwsub-explorer → Skills: コードベース探索手法
  - vwsub-developer → Skills: TDD実装パターン
  - vwsub-reviewer → Skills: 品質評価基準
```

**メリット**:
- SubAgentsの独立環境内でのみSkillsを展開（コンテキスト効率化）
- 同じSkillを複数のSubAgentで共有（再利用性向上）
- 責任の明確化：SubAgents = タスク実行、Skills = 専門知識

### 高優先度（即座に採用すべき）

#### 4. プラグイン化の検討（重要度: 高）
**現状**: 現在の`.claude/`構造は、シンボリックリンクで直接ユーザーディレクトリに配置

**推奨**:
```
ccSlashCmd-dev/
├── plugins/
│   └── ccslashcmd-core/
│       ├── .claude-plugin/
│       │   └── plugin.json
│       ├── agents/          # 現在の.claude/agents/を移行
│       ├── commands/        # 現在の.claude/commands/を移行
│       ├── skills/          # 新規作成（prompts/を段階的開示化）
│       └── hooks/
│           └── hooks.json   # 現在の.claude/hooks/を統合
└── marketplace/
    └── .claude-plugin/
        └── marketplace.json
```

**メリット**:
- チーム配布の標準化（`.claude/settings.json`で自動インストール）
- バージョン管理の明確化
- 依存関係の明示化
- 他プロジェクトでの再利用

#### 2. スキルの段階的開示実装（重要度: 高）
**現状**: `prompts/`ディレクトリの各プロンプトは一枚岩

**推奨変換例**（`prompts/explorer.md` → `skills/codebase-exploration/`）:
```
skills/codebase-exploration/
├── SKILL.md                        # メタデータ + 核心指示（1500-2000語）
├── references/
│   ├── advanced-analysis.md        # 深い分析手法
│   └── integration-patterns.md     # 統合パターン
├── examples/
│   └── real-world-exploration.md   # 実例
└── scripts/
    └── generate-report.sh          # ユーティリティ
```

**SKILL.mdフロントマター例**:
```yaml
---
name: codebase-exploration
description: Deeply analyzes existing codebase features by tracing execution paths. Use when exploring code structure, finding similar features, or understanding architecture before implementation.
allowed-tools: Read, Grep, Glob, Bash
---
```

#### 3. フックの`type: "prompt"`活用（重要度: 高）
**現状**: `hooks/`には`auto-format.sh`などのコマンドフックのみ

**推奨追加例**（品質ゲート用プロンプトフック）:
```json
{
  "hooks": {
    "Stop": [
      {
        "hooks": [
          {
            "type": "prompt",
            "prompt": "Analyze the current state:\n1. All tests passing?\n2. Lint/Format clean?\n3. Documentation updated?\n4. CLAUDE.md guidelines followed?\n\nIf all YES, approve. Otherwise, suggest what's missing.",
            "timeout": 10
          }
        ]
      }
    ]
  }
}
```

**メリット**: LLMによるインテリジェントな品質チェック

### 中優先度（段階的に移行すべき）

#### 4. サブエージェント強化（重要度: 中）
**現状**: `description`フィールドが簡潔すぎる可能性

**推奨改善**（`vwsub-explorer.md`の例）:
```yaml
# 現在
description: コードベース探索専門。既存コードの調査と要件の明確化を担当

# 推奨
description: Codebase exploration specialist. Use PROACTIVELY when starting new features, refactoring, or investigating bugs. Analyzes existing code structure, patterns, and dependencies. MUST BE USED before design or implementation phases to ensure understanding of existing architecture.
```

**追加フィールド**:
```yaml
color: blue          # UI識別用
model: sonnet        # モデル明示
```

#### 5. MCPサーバー統合の検討（重要度: 中）
**潜在的統合先**:
- **Context7**: プロジェクトコンテキスト管理
- **Playwright**: E2Eテスト自動化（`qa-playwright-tester`エージェント強化）
- **GitHub MCP**: PRコメント取得、イシュー管理
- **Gemini MCP**: Web検索（現在`gemini` CLIを使用）

**.mcp.json例**（Playwright統合）:
```json
{
  "mcpServers": {
    "playwright": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-playwright"],
      "env": {
        "PLAYWRIGHT_BROWSERS_PATH": "${CLAUDE_PLUGIN_ROOT}/.browsers"
      }
    }
  }
}
```

#### 6. `ref_code/plugins/`の参考実装活用（重要度: 中）
**学ぶべき実装パターン**:

**feature-dev プラグイン**:
- ✅ 7フェーズワークフロー（Discovery → Exploration → Questions → Design → Implementation → Review → Summary）
- ✅ 3つの専門エージェント（code-explorer, code-architect, code-reviewer）
- ✅ 並列エージェント実行（Phase 2, 4, 6）
- ✅ 明示的な承認ゲート（Phase 3, 5）

**plugin-dev ツールキット**:
- ✅ 7つの専門スキル（hook-dev, mcp-integration, plugin-structure, etc.）
- ✅ 段階的開示の模範（SKILL.md → references/ → examples/ → scripts/）
- ✅ 検証ユーティリティ（validate-hook-schema.sh, test-hook.sh）
- ✅ AI支援エージェント生成（agent-creator）

**採用可能な要素**:
1. **明示的承認ゲート**: 実装前に必ずユーザー確認
2. **並列エージェント実行**: 複数視点からの分析
3. **検証スクリプト**: `validate-agent.sh`, `validate-hook-schema.sh`
4. **AI支援生成**: 新規エージェント/スキル作成の自動化

### 低優先度（後回しにできる）

#### 7. カスタムモデル選択（重要度: 低）
- 現在の`model: sonnet`は適切
- 必要に応じて`haiku`（軽量タスク）、`opus`（複雑タスク）を選択可能

#### 8. エージェント再開機能（重要度: 低）
- 長時間実行される調査タスクでのみ有効
- 現在のワークフローでは不要

#### 9. プラグインマーケットプレイスの公開（重要度: 低）
- 組織内配布が優先
- 外部公開は成熟後に検討

---

## 6. 次フェーズへの引き継ぎ事項

### 6.1 Analystフェーズへの質問

1. **プラグイン化のタイミング**:
   - 即座に移行すべきか、段階的か？
   - プラグイン化による影響範囲は？
   - 既存のシンボリックリンク構成との互換性維持方法は？

2. **スキル変換の優先順位**:
   - どのプロンプトから`skills/`化すべきか？
   - 段階的開示の粒度はどの程度が最適か？
   - 既存エージェントとの役割重複をどう解消するか？

3. **フックの実装範囲**:
   - どのフックイベントを優先すべきか？
   - `type: "prompt"`フックの適用基準は？
   - 既存の`auto-format.sh`などとの統合方法は？

4. **MCP統合の必要性**:
   - 現在のワークフローでMCPが解決する問題は何か？
   - どのMCPサーバーが最も価値があるか？
   - 導入コストとメリットのバランスは？

### 6.2 技術的検討事項

#### 互換性維持
- 現在のシンボリックリンク構成を維持しつつプラグイン化可能か？
- 既存のエージェント/コマンドを壊さずに移行する手順は？

#### テスト戦略
- プラグイン化後の動作検証方法は？
- スキル変換後のトリガー動作テスト方法は？
- フック実装のテストフレームワークは？

#### ドキュメント更新
- `CLAUDE.md`のどの部分を更新すべきか？
- 旧設計ドキュメント（`20250620_claude-default-multiagent-design.md`）の扱いは？
- `README.md`への反映内容は？

### 6.3 リスク要因

| リスク | 影響度 | 対策 |
|--------|--------|------|
| プラグイン化による既存機能の破壊 | 高 | 段階的移行、十分なテスト |
| スキル変換によるトリガー失敗 | 中 | `description`フィールドの最適化、テスト |
| フック実装の複雑化 | 中 | シンプルなフックから開始 |
| MCP統合の学習コスト | 低 | 段階的導入、既存ツール優先 |

---

## 結論（✅更新：現実的な実装に焦点）

**doc/ディレクトリ（公式ドキュメント + 最新ブログ）は、Claude Codeの実践的なアーキテクチャへの移行ロードマップを提供しています**

**最も重要な発見**（現実的な実装優先度順）:

1. **🔥 Progressive Disclosure**: スキル3層構造（L1→L2→L3）
   - メタデータのみ初期ロード、本文は必要時のみ
   - **65%コンテキスト削減**（15,000 → 5,300トークン）の実績
   - SKILL.md 500行、description 1024文字の厳格な制約
   - **即座に実装可能**

2. **🔥 エージェント数最適化**: 13→8に統合
   - 機能の重複・類似性を解消
   - エージェント発見性: 60% → 90%以上
   - 適切なエージェント選択率: 50% → 85%以上
   - **即座に実装可能**

3. **⭐ SubAgent→Skills連携**: 公式推奨パターン
   - SubAgents = タスク実行エンジン
   - Skills = 専門知識データベース
   - 独立環境での展開により再利用性と効率性を両立
   - **Progressive Disclosure実装後に追加**

4. **📚 将来的な方向性**（参考情報）:
   - Code Execution × MCP（98.7%削減の実績あり）
   - MCPの本質理解（ツール = プロンプト）
   - **現時点では実装見送り、将来的な検討課題**

5. **プラグインエコシステム**が公式の標準となり、旧`slashCommand`や`worktree`ベースは廃止

6. **`ref_code/plugins/`**には、世界クラスの実装例（feature-dev, plugin-dev）が存在

**現在のプロジェクト状態の評価**:
- ✅ **エージェントベース移行完了**（先進的）
- ❌ **Progressive Disclosure未実装**（65%削減可能、最優先課題）
- ❌ **エージェント数が多すぎる**（13→8統合必要、高優先度）
- ❌ **SubAgent→Skills連携なし**（公式推奨パターン未採用）
- ⚠️ **プラグイン化未完**（配布標準化の余地、オプション）
- 📚 **Code Execution × MCP未実装**（将来的な検討課題）

**実現可能性評価**:
このプロジェクトは、**Progressive Disclosure**と**エージェント数最適化**という2つの現実的な改善により、即座に**65%コンテキスト削減**と**発見性90%向上**を実現可能。Code Execution × MCPのような革新的だが複雑なアプローチは将来の検討課題とし、まずは実装可能な改善に集中することで、確実な成果を得られる。

**推奨実装順序**（現実的優先度）:
1. 🔥 **エージェント数最適化**（1週） - 13→8統合、発見性向上
2. 🔥 **Progressive Disclosure第1弾**（1週） - explorer.mdをスキル化、効果検証
3. 🔥 **Progressive Disclosure完全実装**（1-2週） - 全6スキル実装
4. ⭐ **SubAgent→Skills連携**（1週） - 公式推奨パターン実装
5. サブエージェント強化（3-5日） - frontmatter最適化
6. プロンプトフック（1週） - 品質ゲート
7. プラグイン化（3-4週）（オプション）

**次ステップ**:
Analystフェーズで、これらの現実的な推奨事項の影響範囲を分析し、段階的な実装戦略を最終決定すべきです。Code Execution × MCPなどの革新的アプローチは、将来のロードマップとして記録しておきます。
