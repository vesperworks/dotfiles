---
created: 2025-06-06T10:30
updated: 2025-06-12T18:40
---
# チュートリアル

> 開発ワークフローでClaude Codeを効果的に使用するための実践的な例とパターン。

このガイドでは、Claude Codeを使った一般的なワークフローのステップバイステップのチュートリアルを提供します。各チュートリアルには、Claude Codeを最大限に活用するための明確な手順、コマンド例、ベストプラクティスが含まれています。

## 目次

* [以前の会話を再開する](#以前の会話を再開する)
* [新しいコードベースを理解する](#新しいコードベースを理解する)
* [バグを効率的に修正する](#バグを効率的に修正する)
* [コードをリファクタリングする](#コードをリファクタリングする)
* [テストを扱う](#テストを扱う)
* [プルリクエストを作成する](#プルリクエストを作成する)
* [ドキュメントを扱う](#ドキュメントを扱う)
* [画像を扱う](#画像を扱う)
* [拡張思考を使用する](#拡張思考を使用する)
* [プロジェクトメモリを設定する](#プロジェクトメモリを設定する)
* [Model Context Protocol (MCP)を設定する](#model-context-protocol-mcpを設定する)
* [Claudeをunixスタイルのユーティリティとして使用する](#claudeをunixスタイルのユーティリティとして使用する)
* [カスタムスラッシュコマンドを作成する](#カスタムスラッシュコマンドを作成する)
* [Gitワークツリーで並列Claude Codeセッションを実行する](#gitワークツリーで並列claude-codeセッションを実行する)

## 以前の会話を再開する

### シームレスに作業を継続する

**使用するタイミング:** Claude Codeでタスクに取り組んでいて、後のセッションで中断した箇所から続ける必要がある場合。

Claude Codeは以前の会話を再開するための2つのオプションを提供しています：

* `--continue` で最新の会話を自動的に継続
* `--resume` で会話選択ピッカーを表示

<Steps>
  <Step title="最新の会話を継続する">
    ```bash
    claude --continue
    ```

    これにより、プロンプトなしで最新の会話がすぐに再開されます。
  </Step>

  <Step title="非インタラクティブモードで継続する">
    ```bash
    claude --continue --print "Continue with my task"
    ```

    `--print`を`--continue`と一緒に使用すると、最新の会話を非インタラクティブモードで再開できます。スクリプトや自動化に最適です。
  </Step>

  <Step title="会話ピッカーを表示する">
    ```bash
    claude --resume
    ```

    これにより、以下を表示するインタラクティブな会話セレクターが表示されます：

    * 会話開始時間
    * 初期プロンプトまたは会話の要約
    * メッセージ数

    矢印キーで移動し、Enterキーを押して会話を選択します。
  </Step>
</Steps>

**仕組み：**

1. **会話ストレージ**: すべての会話は完全なメッセージ履歴とともに自動的にローカルに保存されます
2. **メッセージの逆シリアル化**: 再開時、コンテキストを維持するために全メッセージ履歴が復元されます
3. **ツールの状態**: 以前の会話からのツールの使用と結果が保持されます
4. **コンテキストの復元**: 会話は以前のコンテキストをすべて保持したまま再開されます

**ヒント：**

* 会話履歴はマシンにローカルに保存されます
* 最新の会話にすぐにアクセスするには`--continue`を使用します
* 特定の過去の会話を選択する必要がある場合は`--resume`を使用します
* 再開すると、続行する前に会話履歴全体が表示されます
* 再開された会話は、元の会話と同じモデルと構成で開始されます

**例：**

```bash
# 最新の会話を継続
claude --continue

# 特定のプロンプトで最新の会話を継続
claude --continue --print "Show me our progress"

# 会話ピッカーを表示
claude --resume

# 非インタラクティブモードで最新の会話を継続
claude --continue --print "Run the tests again"
```

## 新しいコードベースを理解する

### コードベースの概要をすばやく把握する

**使用するタイミング:** 新しいプロジェクトに参加したばかりで、その構造をすばやく理解する必要がある場合。

<Steps>
  <Step title="プロジェクトのルートディレクトリに移動する">
    ```bash
    cd /path/to/project 
    ```
  </Step>

  <Step title="Claude Codeを起動する">
    ```bash
    claude 
    ```
  </Step>

  <Step title="高レベルの概要を尋ねる">
    ```
    > このコードベースの概要を教えてください 
    ```
  </Step>

  <Step title="特定のコンポーネントについて詳しく調べる">
    ```
    > ここで使用されている主なアーキテクチャパターンを説明してください 
    ```

    ```
    > 主要なデータモデルは何ですか？
    ```

    ```
    > 認証はどのように処理されていますか？
    ```
  </Step>
</Steps>

**ヒント：**

* 広範な質問から始めて、特定の領域に絞り込んでいきます
* プロジェクトで使用されているコーディング規約やパターンについて尋ねます
* プロジェクト固有の用語の用語集を要求します

### 関連するコードを見つける

**使用するタイミング:** 特定の機能や機能に関連するコードを見つける必要がある場合。

<Steps>
  <Step title="関連ファイルを見つけるようClaudeに依頼する">
    ```
    > ユーザー認証を処理するファイルを見つけてください 
    ```
  </Step>

  <Step title="コンポーネントがどのように相互作用するかのコンテキストを取得する">
    ```
    > これらの認証ファイルはどのように連携していますか？ 
    ```
  </Step>

  <Step title="実行フローを理解する">
    ```
    > フロントエンドからデータベースまでのログインプロセスを追跡してください 
    ```
  </Step>
</Steps>

**ヒント：**

* 探しているものについて具体的に説明します
* プロジェクトのドメイン言語を使用します

***

## バグを効率的に修正する

### エラーメッセージを診断する

**使用するタイミング:** エラーメッセージが発生し、その原因を見つけて修正する必要がある場合。

<Steps>
  <Step title="エラーをClaudeと共有する">
    ```
    > npm testを実行すると、エラーが発生します 
    ```
  </Step>

  <Step title="修正の推奨事項を求める">
    ```
    > user.tsの@ts-ignoreを修正するいくつかの方法を提案してください 
    ```
  </Step>

  <Step title="修正を適用する">
    ```
    > 提案したnullチェックを追加するようにuser.tsを更新してください 
    ```
  </Step>
</Steps>

**ヒント：**

* エラーを再現するコマンドとスタックトレースをClaudeに伝えます
* エラーを再現するための手順を説明します
* エラーが断続的か一貫しているかをClaudeに伝えます

***

## コードをリファクタリングする

### レガシーコードを最新化する

**使用するタイミング:** 古いコードを最新のパターンと実践に更新する必要がある場合。

<Steps>
  <Step title="リファクタリングするレガシーコードを特定する">
    ```
    > コードベースで非推奨APIの使用を見つけてください 
    ```
  </Step>

  <Step title="リファクタリングの推奨事項を取得する">
    ```
    > utils.jsを最新のJavaScript機能を使用するようにリファクタリングする方法を提案してください 
    ```
  </Step>

  <Step title="変更を安全に適用する">
    ```
    > 同じ動作を維持しながら、utils.jsをES2024機能を使用するようにリファクタリングしてください 
    ```
  </Step>

  <Step title="リファクタリングを検証する">
    ```
    > リファクタリングされたコードのテストを実行してください 
    ```
  </Step>
</Steps>

**ヒント：**

* 最新のアプローチのメリットをClaudeに説明してもらいます
* 必要に応じて、変更が後方互換性を維持するよう要求します
* リファクタリングは小さく、テスト可能な単位で行います

***

## テストを扱う

### テストカバレッジを追加する

**使用するタイミング:** カバーされていないコードにテストを追加する必要がある場合。

<Steps>
  <Step title="テストされていないコードを特定する">
    ```
    > NotificationsService.swiftでテストでカバーされていない関数を見つけてください 
    ```
  </Step>

  <Step title="テストの足場を生成する">
    ```
    > 通知サービスのテストを追加してください 
    ```
  </Step>

  <Step title="意味のあるテストケースを追加する">
    ```
    > 通知サービスのエッジケースのテストケースを追加してください 
    ```
  </Step>

  <Step title="テストを実行して検証する">
    ```
    > 新しいテストを実行し、失敗があれば修正してください 
    ```
  </Step>
</Steps>

**ヒント：**

* エッジケースとエラー条件をカバーするテストを依頼します
* 適切な場合は、ユニットテストと統合テストの両方を要求します
* テスト戦略をClaudeに説明してもらいます

***

## プルリクエストを作成する

### 包括的なPRを生成する

**使用するタイミング:** 変更内容について十分に文書化されたプルリクエストを作成する必要がある場合。

<Steps>
  <Step title="変更内容を要約する">
    ```
    > 認証モジュールに加えた変更を要約してください 
    ```
  </Step>

  <Step title="Claudeでプルリクエストを生成する">
    ```
    > PRを作成してください 
    ```
  </Step>

  <Step title="レビューと改善">
    ```
    > セキュリティ改善に関するより多くのコンテキストでPRの説明を強化してください 
    ```
  </Step>

  <Step title="テスト詳細を追加する">
    ```
    > これらの変更がどのようにテストされたかについての情報を追加してください 
    ```
  </Step>
</Steps>

**ヒント：**

* PRを作成するようClaudeに直接依頼します
* 提出する前にClaudeが生成したPRをレビューします
* 潜在的なリスクや考慮事項を強調するようClaudeに依頼します

## ドキュメントを扱う

### コードドキュメントを生成する

**使用するタイミング:** コードのドキュメントを追加または更新する必要がある場合。

<Steps>
  <Step title="ドキュメント化されていないコードを特定する">
    ```
    > 認証モジュールで適切なJSDocコメントがない関数を見つけてください 
    ```
  </Step>

  <Step title="ドキュメントを生成する">
    ```
    > auth.jsのドキュメント化されていない関数にJSDocコメントを追加してください 
    ```
  </Step>

  <Step title="レビューと強化">
    ```
    > 生成されたドキュメントをより多くのコンテキストと例で改善してください 
    ```
  </Step>

  <Step title="ドキュメントを検証する">
    ```
    > ドキュメントがプロジェクト標準に従っているか確認してください 
    ```
  </Step>
</Steps>

**ヒント：**

* 希望するドキュメントスタイル（JSDoc、docstringsなど）を指定します
* ドキュメントに例を含めるよう依頼します
* パブリックAPI、インターフェース、複雑なロジックのドキュメントを要求します

## 画像を扱う

### 画像とスクリーンショットを分析する

**使用するタイミング:** コードベースで画像を扱う必要がある場合や、画像コンテンツの分析にClaudeの助けが必要な場合。

<Steps>
  <Step title="会話に画像を追加する">
    以下のいずれかの方法を使用できます：

    1. Claude Codeウィンドウに画像をドラッグアンドドロップする
    2. 画像をコピーしてcmd+v（Mac）でCLIに貼り付ける
    3. 画像パスを提供する：claude "この画像を分析してください：/path/to/your/image.png"
  </Step>

  <Step title="Claudeに画像を分析してもらう">
    ```
    > この画像は何を示していますか？ 
    > このスクリーンショットのUI要素を説明してください 
    > この図に問題のある要素はありますか？ 
    ```
  </Step>

  <Step title="コンテキストとして画像を使用する">
    ```
    > これはエラーのスクリーンショットです。何が原因ですか？ 
    > これは現在のデータベーススキーマです。新機能のためにどのように修正すべきですか？ 
    ```
  </Step>

  <Step title="視覚的コンテンツからコード提案を取得する">
    ```
    > このデザインモックアップに合わせたCSSを生成してください 
    > このコンポーネントを再現するにはどのようなHTML構造が必要ですか？ 
    ```
  </Step>
</Steps>

**ヒント：**

* テキストでの説明が不明確または煩雑な場合は画像を使用します
* より良いコンテキストのために、エラー、UIデザイン、または図のスクリーンショットを含めます
* 会話で複数の画像を扱うことができます
* 画像分析は図、スクリーンショット、モックアップなどで機能します

***

## 拡張思考を使用する

### 複雑なタスクにClaudeの拡張思考を活用する

**使用するタイミング:** 複雑なアーキテクチャの決定、難しいバグ、または深い推論を必要とする複数ステップの実装計画に取り組んでいる場合。

<Steps>
  <Step title="コンテキストを提供し、Claudeに考えてもらう">
    ```
    > APIのためにOAuth2を使用した新しい認証システムを実装する必要があります。コードベースでこれを実装するための最良のアプローチについて深く考えてください。 
    ```

    Claudeはコードベースから関連情報を収集し、
    インターフェースに表示される拡張思考を使用します。
  </Step>

  <Step title="フォローアッププロンプトで思考を洗練させる">
    ```
    > このアプローチの潜在的なセキュリティ脆弱性について考えてください 
    > 処理すべきエッジケースについてさらに深く考えてください 
    ```
  </Step>
</Steps>

**拡張思考から最大限の価値を得るためのヒント：**

拡張思考は以下のような複雑なタスクに最も価値があります：

* 複雑なアーキテクチャ変更の計画
* 複雑な問題のデバッグ
* 新機能の実装計画の作成
* 複雑なコードベースの理解
* 異なるアプローチ間のトレードオフの評価

思考を促す方法によって、思考の深さのレベルが異なります：

* 「考えて」は基本的な拡張思考をトリガーします
* 「もっと考えて」、「たくさん考えて」、「より深く考えて」、「より長く考えて」などの強調フレーズはより深い思考をトリガーします

拡張思考のプロンプトに関するさらなるヒントについては、[拡張思考のヒント](/ja/docs/build-with-claude/prompt-engineering/extended-thinking-tips)を参照してください。

<Note>
  Claudeは思考プロセスを応答の上にイタリック体のグレーテキストとして表示します。
</Note>

***

## プロジェクトメモリを設定する

### 効果的なCLAUDE.mdファイルを作成する

**使用するタイミング:** 重要なプロジェクト情報、規約、頻繁に使用されるコマンドを保存するためのCLAUDE.mdファイルを設定したい場合。

<Steps>
  <Step title="コードベース用のCLAUDE.mdをブートストラップする">
    ```
    > /init 
    ```
  </Step>
</Steps>

**ヒント：**

* 頻繁に使用されるコマンド（ビルド、テスト、リント）を含めて、繰り返しの検索を避けます
* コードスタイルの設定と命名規則を文書化します
* プロジェクト固有の重要なアーキテクチャパターンを追加します
* CLAUDE.mdメモリは、チームと共有する指示とあなた個人の設定の両方に使用できます。詳細については、[Claudeのメモリの管理](/ja/docs/agents-and-tools/claude-code/overview#manage-claudes-memory)を参照してください。

***

## Model Context Protocol (MCP)を設定する

Model Context Protocol (MCP)は、LLMが外部ツールやデータソースにアクセスできるようにするオープンプロトコルです。詳細については、[MCPドキュメント](https://modelcontextprotocol.io/introduction)を参照してください。

<Warning>
  サードパーティのMCPサーバーは自己責任で使用してください。MCPサーバーを信頼していることを確認し、特にインターネットと通信するMCPサーバーを使用する場合は、プロンプトインジェクションのリスクにさらされる可能性があるため、特に注意してください。
</Warning>

### MCPサーバーを構成する

**使用するタイミング:** Model Context Protocolを使用して、Claudeの機能を専門ツールや外部サーバーに接続して強化したい場合。

<Steps>
  <Step title="MCP Stdioサーバーを追加する">
    ```bash
    # 基本構文
    claude mcp add <name> <command> [args...]

    # 例：ローカルサーバーの追加
    claude mcp add my-server -e API_KEY=123 -- /path/to/server arg1 arg2
    ```
  </Step>

  <Step title="MCP SSEサーバーを追加する">
    ```bash
    # 基本構文
    claude mcp add --transport sse <name> <url>

    # 例：SSEサーバーの追加
    claude mcp add --transport sse sse-server https://example.com/sse-endpoint
    ```
  </Step>

  <Step title="MCPサーバーを管理する">
    ```bash
    # 構成されたすべてのサーバーをリストする
    claude mcp list

    # 特定のサーバーの詳細を取得する
    claude mcp get my-server

    # サーバーを削除する
    claude mcp remove my-server
    ```
  </Step>
</Steps>

**ヒント：**

* `-s`または`--scope`フラグを使用して、構成が保存される場所を指定します：
  * `local`（デフォルト）：現在のプロジェクトであなただけが利用可能（古いバージョンでは`project`と呼ばれていました）
  * `project`：`.mcp.json`ファイルを介してプロジェクト内の全員と共有
  * `user`：すべてのプロジェクトであなたが利用可能（古いバージョンでは`global`と呼ばれていました）
* `-e`または`--env`フラグで環境変数を設定します（例：`-e KEY=value`）
* MCP\_TIMEOUT環境変数を使用してMCPサーバーの起動タイムアウトを構成します（例：`MCP_TIMEOUT=10000 claude`で10秒のタイムアウトを設定）
* Claude Code内で`/mcp`コマンドを使用して、いつでもMCPサーバーのステータスを確認できます
* MCPはクライアント-サーバーアーキテクチャに従っており、Claude Code（クライアント）は複数の専門サーバーに接続できます

### MCPサーバースコープを理解する

**使用するタイミング:** 異なるMCPスコープがどのように機能するか、およびサーバーをチームと共有する方法を理解したい場合。

<Steps>
  <Step title="ローカルスコープのMCPサーバー">
    デフォルトのスコープ（`local`）は、プロジェクト固有のユーザー設定にMCPサーバー構成を保存します。これらのサーバーは、現在のプロジェクトで作業している間、あなただけが利用できます。

    ```bash
    # ローカルスコープのサーバーを追加（デフォルト）
    claude mcp add my-private-server /path/to/server

    # 明示的にローカルスコープを指定
    claude mcp add my-private-server -s local /path/to/server
    ```
  </Step>

  <Step title="プロジェクトスコープのMCPサーバー（.mcp.json）">
    プロジェクトスコープのサーバーは、プロジェクトのルートにある`.mcp.json`ファイルに保存されます。このファイルはバージョン管理にチェックインして、チームとサーバーを共有する必要があります。

    ```bash
    # プロジェクトスコープのサーバーを追加
    claude mcp add shared-server -s project /path/to/server
    ```

    これにより、以下の構造の`.mcp.json`ファイルが作成または更新されます：

    ```json
    {
      "mcpServers": {
        "shared-server": {
          "command": "/path/to/server",
          "args": [],
          "env": {}
        }
      }
    }
    ```
  </Step>

  <Step title="ユーザースコープのMCPサーバー">
    ユーザースコープのサーバーは、マシン上のすべてのプロジェクトであなたが利用でき、あなた専用です。

    ```bash
    # ユーザーサーバーを追加
    claude mcp add my-user-server -s user /path/to/server
    ```
  </Step>
</Steps>

**ヒント：**

* 同じ名前のローカルスコープのサーバーは、プロジェクトスコープとユーザースコープのサーバーよりも優先されます
* 同じ名前のプロジェクトスコープのサーバー（`.mcp.json`内）は、ユーザースコープのサーバーよりも優先されます
* セキュリティのため、Claude Codeは`.mcp.json`からプロジェクトスコープのサーバーを使用する前に承認を求めます
* `.mcp.json`ファイルはバージョン管理にチェックインして、チームとMCPサーバーを共有することを意図しています
* プロジェクトスコープのサーバーを使用すると、チームの全員が同じMCPツールにアクセスできるようになります
* 有効または無効にするプロジェクトスコープのサーバーの選択をリセットする必要がある場合は、`claude mcp reset-project-choices`コマンドを使用します

### PostgresのMCPサーバーに接続する

**使用するタイミング:** Claudeに読み取り専用のPostgreSQLデータベースへのアクセスを提供して、クエリとスキーマ検査を行いたい場合。

<Steps>
  <Step title="PostgresのMCPサーバーを追加する">
    ```bash
    claude mcp add postgres-server /path/to/postgres-mcp-server --connection-string "postgresql://user:pass@localhost:5432/mydb"
    ```
  </Step>

  <Step title="Claudeでデータベースをクエリする">
    ```
    # Claudeセッションで、データベースについて質問できます

    > usersテーブルのスキーマを説明してください
    > システム内の最新の注文は何ですか？
    > 顧客と請求書の関係を示してください
    ```
  </Step>
</Steps>

**ヒント：**

* PostgresのMCPサーバーは安全のために読み取り専用アクセスを提供します
* Claudeはデータベース構造の探索と分析クエリの実行を支援できます
* これを使用して、不慣れなプロジェクトのデータベーススキーマをすばやく理解できます
* 接続文字列が最小限必要な権限を持つ適切な認証情報を使用していることを確認してください

### JSON構成からMCPサーバーを追加する

**使用するタイミング:** Claude Codeに追加したい単一のMCPサーバーのJSON構成がある場合。

<Steps>
  <Step title="JSONからMCPサーバーを追加する">
    ```bash
    # 基本構文
    claude mcp add-json <name> '<json>'

    # 例：JSON構成でstdioサーバーを追加する
    claude mcp add-json weather-api '{"type":"stdio","command":"/path/to/weather-cli","args":["--api-key","abc123"],"env":{"CACHE_DIR":"/tmp"}}'
    ```
  </Step>

  <Step title="サーバーが追加されたことを確認する">
    ```bash
    claude mcp get weather-api
    ```
  </Step>
</Steps>

**ヒント：**

* JSONがシェルで適切にエスケープされていることを確認してください
* JSONはMCPサーバー構成スキーマに準拠している必要があります
* プロジェクト固有の構成ではなくグローバル構成にサーバーを追加するには、`-s global`を使用できます

### Claude DesktopからMCPサーバーをインポートする

**使用するタイミング:** すでにClaude DesktopでMCPサーバーを構成しており、手動で再構成することなく同じサーバーをClaude Codeで使用したい場合。

<Steps>
  <Step title="Claude Desktopからサーバーをインポートする">
    ```bash
    # 基本構文 
    claude mcp add-from-claude-desktop 
    ```
  </Step>

  <Step title="インポートするサーバーを選択する">
    コマンドを実行すると、インポートするサーバーを選択できるインタラクティブなダイアログが表示されます。
  </Step>

  <Step title="サーバーがインポートされたことを確認する">
    ```bash
    claude mcp list 
    ```
  </Step>
</Steps>

**ヒント：**

* この機能はmacOSとWindows Subsystem for Linux（WSL）でのみ動作します
* これらのプラットフォームの標準的な場所からClaude Desktop構成ファイルを読み込みます
* サーバーをグローバル構成に追加するには、`-s global`フラグを使用します
* インポートされたサーバーはClaude Desktopと同じ名前になります
* 同じ名前のサーバーがすでに存在する場合、数値サフィックスが付きます（例：`server_1`）

### Claude Code自体をMCPサーバーとして使用する

**使用するタイミング:** Claude Code自体をMCPサーバーとして使用して、他のアプリケーションがClaudeのツールと機能に接続できるようにしたい場合。

<Steps>
  <Step title="ClaudeをMCPサーバーとして起動する">
    ```bash
    # 基本構文
    claude mcp serve
    ```
  </Step>

  <Step title="別のアプリケーションから接続する">
    Claude Code MCPサーバーには、Claude DesktopなどのMCPクライアントから接続できます。Claude Desktopを使用している場合は、この構成を使用してClaude Code MCPサーバーを追加できます：

    ```json
    {
      "command": "claude",
      "args": ["mcp", "serve"],
      "env": {}
    }
    ```
  </Step>
</Steps>

**ヒント：**

* サーバーはView、Edit、LSなどのClaudeのツールへのアクセスを提供します
* Claude Desktopでは、ディレクトリ内のファイルの読み取り、編集などをClaudeに依頼してみてください
* このMCPサーバーは単にClaude CodeのツールをあなたのMCPクライアントに公開しているだけであり、個々のツール呼び出しのユーザー確認を実装する責任はあなた自身のクライアントにあることに注意してください

***

## Claudeをunixスタイルのユーティリティとして使用する

### 検証プロセスにClaudeを追加する

**使用するタイミング:** Claude Codeをリンターやコードレビュアーとして使用したい場合。

**手順：**

<Steps>
  <Step title="ビルドスクリプトにClaudeを追加する">
    ```json
    // package.json
    {
        ...
        "scripts": {
            ...
            "lint:claude": "claude -p 'you are a linter. please look at the changes vs. main and report any issues related to typos. report the filename and line number on one line, and a description of the issue on the second line. do not return any other text.'"
        }
    }
    ```
  </Step>
</Steps>

### パイプイン、パイプアウト

**使用するタイミング:** データをClaudeにパイプし、構造化された形式でデータを取得したい場合。

<Steps>
  <Step title="Claudeを通じてデータをパイプする">
    ```bash
    cat build-error.txt | claude -p 'このビルドエラーの根本原因を簡潔に説明してください' > output.txt
    ```
  </Step>
</Steps>

### 出力形式を制御する

**使用するタイミング:** 特にClaude Codeをスクリプトや他のツールに統合する場合に、特定の形式でClaudeの出力が必要な場合。

<Steps>
  <Step title="テキスト形式を使用する（デフォルト）">
    ```bash
    cat data.txt | claude -p 'このデータを要約してください' --output-format text > summary.txt
    ```

    これはClaudeのプレーンテキスト応答のみを出力します（デフォルトの動作）。
  </Step>

  <Step title="JSON形式を使用する">
    ```bash
    cat code.py | claude -p 'このコードのバグを分析してください' --output-format json > analysis.json
    ```

    これはコストと期間を含むメタデータを持つメッセージのJSON配列を出力します。
  </Step>

  <Step title="ストリーミングJSON形式を使用する">
    ```bash
    cat log.txt | claude -p 'このログファイルからエラーを解析してください' --output-format stream-json
    ```

    これはClaudeがリクエストを処理するときにリアルタイムで一連のJSONオブジェクトを出力します。各メッセージは有効なJSONオブジェクトですが、連結された場合、出力全体は有効なJSONではありません。
  </Step>
</Steps>

**ヒント：**

* Claudeの応答だけが必要な単純な統合には`--output-format text`を使用します
* 完全な会話ログが必要な場合は`--output-format json`を使用します
* 各会話ターンのリアルタイム出力には`--output-format stream-json`を使用します

***

## カスタムスラッシュコマンドを作成する

Claude Codeは、特定のプロンプトやタスクをすばやく実行するためのカスタムスラッシュコマンドの作成をサポートしています。

### プロジェクト固有のコマンドを作成する

**使用するタイミング:** チームの全メンバーが使用できるプロジェクト用の再利用可能なスラッシュコマンドを作成したい場合。

<Steps>
  <Step title="プロジェクトにコマンドディレクトリを作成する">
    ```bash
    mkdir -p .claude/commands
    ```
  </Step>

  <Step title="各コマンド用のMarkdownファイルを作成する">
    ```bash
    echo "このコードのパフォーマンスを分析し、3つの具体的な最適化を提案してください：" > .claude/commands/optimize.md 
    ```
  </Step>

  <Step title="Claude Codeでカスタムコマンドを使用する">
    ```bash
    claude > /project:optimize 
    ```
  </Step>
</Steps>

**ヒント：**

* コマンド名はファイル名から派生します（例：`optimize.md`は`/project:optimize`になります）
* サブディレクトリにコマンドを整理できます（例：`.claude/commands/frontend/component.md`は`/project:frontend:component`になります）
* プロジェクトコマンドはリポジトリをクローンする全員が利用できます
* Markdownファイルの内容は、コマンドが呼び出されたときにClaudeに送信されるプロンプトになります

### \$ARGUMENTSでコマンド引数を追加する

**使用するタイミング:** ユーザーから追加入力を受け付けることができる柔軟なスラッシュコマンドを作成したい場合。

<Steps>
  <Step title="$ARGUMENTSプレースホルダーを含むコマンドファイルを作成する">
    ```bash
    echo "問題 #$ARGUMENTS を見つけて修正してください。次の手順に従ってください：1.
    チケットに記載されている問題を理解する 2. コードベース内の関連コードを特定する 3.
    根本原因に対処するソリューションを実装する 4. 適切なテストを追加する 5.
    簡潔なPR説明を準備する" > .claude/commands/fix-issue.md 
    ```
  </Step>

  <Step title="問題番号を指定してコマンドを使用する">
    ```bash
    claude > /project:fix-issue 123 
    ```

    これにより、プロンプト内の\$ARGUMENTSが「123」に置き換えられます。
  </Step>
</Steps>

**ヒント：**

* \$ARGUMENTSプレースホルダーは、コマンドに続くテキストに置き換えられます
* コマンドテンプレートの任意の場所に\$ARGUMENTSを配置できます
* その他の有用な用途：特定の関数のテストケースの生成、コンポーネントのドキュメント作成、特定のファイル内のコードのレビュー、または指定された言語へのコンテンツの翻訳

### 個人用スラッシュコマンドを作成する

**使用するタイミング:** すべてのプロジェクトで機能する個人用スラッシュコマンドを作成したい場合。

<Steps>
  <Step title="ホームフォルダにコマンドディレクトリを作成する">
    ```bash
    mkdir -p ~/.claude/commands 
    ```
  </Step>

  <Step title="各コマンド用のMarkdownファイルを作成する">
    ```bash
    echo "このコードをセキュリティ脆弱性について確認し、以下に焦点を当ててください：" >
    ~/.claude/commands/security-review.md 
    ```
  </Step>

  <Step title="個人用カスタムコマンドを使用する">
    ```bash
    claude > /user:security-review 
    ```
  </Step>
</Steps>

**ヒント：**

* 個人用コマンドは`/project:`ではなく`/user:`をプレフィックスとします
* 個人用コマンドはあなただけが利用でき、チームとは共有されません
* 個人用コマンドはすべてのプロジェクトで機能します
* これらを使用して、異なるコードベース間で一貫したワークフローを実現できます

***

## Gitワークツリーで並列Claude Codeセッションを実行する

### 分離されたコーディング環境にワークツリーを使用する

**使用するタイミング:** Claude Codeインスタンス間で完全なコード分離を持つ複数のタスクに同時に取り組む必要がある場合。

<Steps>
  <Step title="Gitワークツリーを理解する">
    Gitワークツリーを使用すると、同じリポジトリから複数のブランチを別々のディレクトリにチェックアウトできます。各ワークツリーには分離されたファイルを持つ独自の作業ディレクトリがありますが、同じGit履歴を共有します。詳細については、[公式Gitワークツリードキュメント](https://git-scm.com/docs/git-worktree)を参照してください。
  </Step>

  <Step title="新しいワークツリーを作成する">
    ```bash
    # 新しいブランチで新しいワークツリーを作成する 
    git worktree add ../project-feature-a -b feature-a

    # または既存のブランチでワークツリーを作成する
    git worktree add ../project-bugfix bugfix-123
    ```

    これにより、リポジトリの別の作業コピーを持つ新しいディレクトリが作成されます。
  </Step>

  <Step title="各ワークツリーでClaude Codeを実行する">
    ```bash
    # ワークツリーに移動する 
    cd ../project-feature-a

    # この分離環境でClaude Codeを実行する
    claude
    ```
  </Step>

  <Step>
    別のターミナルで：

    ```bash
    cd ../project-bugfix
    claude
    ```
  </Step>

  <Step title="ワークツリーを管理する">
    ```bash
    # すべてのワークツリーをリストする
    git worktree list

    # 完了したらワークツリーを削除する
    git worktree remove ../project-feature-a
    ```
  </Step>
</Steps>

**ヒント：**

* 各ワークツリーには独自の独立したファイル状態があり、並列Claude Codeセッションに最適です
* あるワークツリーで行われた変更は他に影響せず、Claudeインスタンスが互いに干渉するのを防ぎます
* すべてのワークツリーは同じGit履歴とリモート接続を共有します
* 長時間実行タスクの場合、あるワークツリーでClaudeに作業させながら、別のワークツリーで開発を続けることができます
* 各ワークツリーがどのタスク用かを簡単に識別できるように、わかりやすいディレクトリ名を使用します
* プロジェクトのセットアップに従って、各新しいワークツリーで開発環境を初期化することを忘れないでください。スタックによっては、以下が含まれる場合があります：
  * JavaScriptプロジェクト：依存関係のインストール（`npm install`、`yarn`）
  * Pythonプロジェクト：仮想環境のセットアップまたはパッケージマネージャーでのインストール
  * その他の言語：プロジェクトの標準セットアッププロセスに従う

***

## 次のステップ

<Card title="Claude Codeリファレンス実装" icon="code" href="https://github.com/anthropics/claude-code/tree/main/.devcontainer">
  開発コンテナリファレンス実装をクローンします。
</Card>
